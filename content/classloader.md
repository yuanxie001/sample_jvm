# java的类加载机制

虚拟机把描述类的数据从class文件加载到内存中,并对数据进行校验,转换解析和初始化,最终形成可以被虚拟机直接使用的java类型.这个机制就是java的类加载机制.

## 1. 触发类加载的时机
虚拟机有且只有如下几种情况会触发Java的类加载:
1. 遇到new, getstatic, putstatic 或者 invokestatic 这4条指令时,如果类没有进行初始化,则需要先触发其初始化.
2. 使用java.lang.reflect包方法对类进行反射调用的时候,如果类没有进行初始化,则需要先触发初始化.
3. 当一个初始化一个类的时候,发现其父类没有被初始化过,则需要先触发父类的初始化.
4. 当虚拟机启动时,用户需要指定一个执行的主类,虚拟机会先初始化这个主类.
5. Java 1.7添加了一个MethodHandle实例解析结果为getStatic,putStatic和invokestatic的方法句柄,如果方法句柄对应的类还没进行初始化,则需要先触发对其初始化.

以上是有且仅有的类初始化的触发场景.其他类型均不能触发类的初始化.如以下几种情况都不会触发类的初始化
- 一个类引用了另一个类的常量.(常量是编译期直接替换为常量本身的字面值了. 如果是常量对象,会触发这个对象所属类的初始化,因为存在new指令)
- 方法入参的时候,或者方法的字节指令里面引用到某个类的情况.这种情况,只有调用的时候才会被初始化,他们引用要么别的方法调用传过来,要么自己调用. 自然也符合上面的情况.
- 创建数组类型,初始化该类型的数组是,不会触发这个类的初始化.

## 2. 类加载的过程

类加载的过程主要分为如下几个步骤: 加载,验证,准备,解析,初始化,使用,卸载.其中加载,验证,准备,初始化 这几个阶段是严格按照顺序执行的.解析不一定,可能在初始化之前,也可能在初始化之后.
![类的生命周期](image/class_lifecycle.png)

### 2.1 加载
加载是将二进制数据加载到虚拟机中,并生成一个对虚拟机可用的class对象入口的过程.主要是通过虚拟机的ClassLoader对二进制数据进行查找并加载.如果没有发现需要加载的类,会抛出ClassNotFoundException.

### 2.2 验证
验证阶段是对class文件合法性的验证.验证主要分为三种类型:文件格式验证,元数据验证和字节码验证.

文件格式验证包括以下内容:
- 文件是不是以0xCAFEBABE开头,表示一个合法的class文件
- 文件的主版本号和次版本号是不是虚拟机所支持的.
- 常量池的常量是否有不被支持的常量类型
- 常量池的各种索引值是否指向不存在的常量或者不符合类型的常量
- CONSTANT_utf8_info型常量是否有不符合utf8编码的数据
- class文件中各部分以及本间本身是否被删除或者附加其他信息

元数据验证:
- 这个类是否存在父类以及父类是否被初始化
- 这个类的父类是否被final修饰的
- 有没有覆写被父类中被final修饰的方法
- 有没有实现接口或者继承抽象类但没有实现其中的抽象方法.
- 子类和父类是否存在矛盾,如覆写方法但修饰符更小等.

字节码校验:
- 校验字节指令和其操作的数据类型保持一致
- 保证跳转指令不会跳转到方法体之外的字节码上
- 保证方法中类型转换是有效的.

以上是验证的主要行为.包括但不限于.

### 2.3 准备
创建类或接口的静态字段,并用默认值初始化这些字段. 这个阶段不执行任何的虚拟机指令. 如果是常量,即static final修饰的,就会在准备时期对该字段进行赋值.

### 2.4 解析
解析是将常量池中符号引用解析为直接引用的过程.主要分为三种类型:类或接口解析,字段解析和方法解析.

类或接口解析:如果当前代码所处的类中存在一个从未解析过的符号引用d,会将其解析成一个直接引用C.
字段解析:如果出现了一个未被解析过的字段符号引用,首先会对字段表中的class_index项进行解析,也就是字段所属类或接口的符号引用.
方法解析:方法解析的第一部也是根据上述方式先对class_index项进行解析,解析完成之后,会对方法进行搜索解析.

在字节码常量池中,有这么几类常量:CONSTANT_Fieldref_info,CONSTANT_Methodref_info,CONSTANT_InterfaceMethodref_info .这几类常量都是对具体对象的一个符号引用.在加载过程中解析成直接引用方便程序调用.其本身并没有太多关于其引用对象的信息.这就是解析过程中解析字段和方法引用的目的.

### 2.5 初始化
初始化阶段是加载的最后一步,主要执行一些特定的行为.主要是static静态代码块和静态变量的显式赋值操作.

## 3. 类加载器
类加载器就是根据一个类的全限定名来读取这个类的二进制文件流到jvm的执行载体. 虚拟机并未规定从什么地方以及什么形式进行加载.
JVM支持两种类型的类加载器:启动类加载器(Bootstrap ClassLoader)和自定义类加载器(UserDifined ClassLoader).
- 启动类加载器:是jvm的一部分.用c++实现的.主要用于加载"JAVA_HOME/lib"目录下的所有类型,或者由-Xbootclasspath指定的路径
- 自定义类加载器:所有派生自ClassLoader的类加载器

### 双亲委派模型
因为jvm中class对象的唯一确定的标记是class和其加载的类加载器保持统一,它就要求不管那个类进行加载,最终获得到的类都是同一个.所以jvm推出了一个双亲委派模型的机制来确保这一点.

![双亲委派模型](image/ClassLoader.png)

双亲委派模型是自定义类加载器用组合的方式(注意不是继承)来实现的加载策略.当类加载器被提交了一个加载请求的时候,会先委托其父加载器进行加载.如果父加载器加载成功则返回,否则就自己加载.