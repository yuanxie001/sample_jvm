# 一个java对象占多大内存

java中,一个对象在虚拟机中占用多大的内存,大多都没有一个直观的答案.所以就想对这个问题深入了解下.

## java对象的组成
一个java对象主要由三个部分组成的.**对象头**,**实例数据**和**对齐填充(padding)**.对齐填充主要存在的意义是因为jvm中内存的分配和扩张都是以8个字节为单位的.所以如果分配了不足8个的.多余的会用字节补齐.

## 对象头
在32位jvm中,对象头是由8个字节组成的.主要分成两部分,前半部分是运行时markword,详细信息如下:

| 锁状态 | 25bit | 4bit | 1bit 是否偏向锁| 2bit锁标记位 |
| ----- | ------ | ------ | --- | -- |
|无锁 | 对象的hashcode | gc年龄分代 | 是 | 01 |
|偏向锁 | 23bit的线程ID,2bit的Epoch | gc年龄分代 | 是 | 01|
|轻量级锁 |指向栈中记录的指针 | | | 00 |
|重量级锁 | 指向重量级锁的指针 | | | 10 |
|GC标记 | 空| | | 11 |
无锁和偏向锁状态下,锁标记位都是01.区别就是前面的是否偏向锁的标记位.

后半部分是klass,指向方法区中当前实例所属类的元数据信息.这部分也占4个字节.
在64位虚拟机中,都会增大一倍,也就是整个对象头占16字节.如果开启了-XX:+UseCompressedOops指针压缩,只会压缩klass的寻址地址.不会压缩运行时的markword.所以,开启 -XX:+UseCompressedOops的对象头大小是12bit. UseCompressedOops参数是默认开启的.
这里的对象年龄分代信息占4bit,表示最大值是15,虚拟机调优标记中-XX:InitialTenuringThreshold=7,-XX:MaxTenuringThreshold这两个标记都是用来控制这个值的.一个是初始值,一个是最大值.这个值可以被虚拟机动态改变的.但这个值最大是15.
## 实例数据
